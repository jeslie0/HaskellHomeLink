-- | Generated by __protobuf__ from file `proto/home.proto`
 module Proto.Home
( StartRadio(..), StartRadioRow, StartRadioR, parseStartRadio, putStartRadio, defaultStartRadio, mkStartRadio, mergeStartRadio
, StopRadio(..), StopRadioRow, StopRadioR, parseStopRadio, putStopRadio, defaultStopRadio, mkStopRadio, mergeStopRadio
, ConnectTCP(..), ConnectTCPRow, ConnectTCPR, parseConnectTCP, putConnectTCP, defaultConnectTCP, mkConnectTCP, mergeConnectTCP
, Envelope(..), EnvelopeRow, EnvelopeR, parseEnvelope, putEnvelope, defaultEnvelope, mkEnvelope, mergeEnvelope, Envelope_Payload(..)
)
where
import Protobuf.Internal.Prelude
import Protobuf.Internal.Prelude as Prelude




-- | Message generated by __protobuf__ from `StartRadio`
newtype StartRadio = StartRadio StartRadioR
type StartRadioRow =
  ( __unknown_fields :: Array Prelude.UnknownField
  )
type StartRadioR = Record StartRadioRow
derive instance genericStartRadio :: Prelude.Generic StartRadio _
derive instance newtypeStartRadio :: Prelude.Newtype StartRadio _
derive instance eqStartRadio :: Prelude.Eq StartRadio
instance showStartRadio :: Prelude.Show StartRadio where show x = Prelude.genericShow x

putStartRadio :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => StartRadio -> Prelude.PutM m Prelude.Unit
putStartRadio (StartRadio r) = do

  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseStartRadio :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m StartRadio
parseStartRadio length = Prelude.label "StartRadio / " $
  Prelude.parseMessage StartRadio defaultStartRadio parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder StartRadioR StartRadioR)

  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultStartRadio :: StartRadioR
defaultStartRadio =
  { __unknown_fields: []
  }

mkStartRadio :: forall r1 r3. Prelude.Union r1 StartRadioRow r3 => Prelude.Nub r3 StartRadioRow => Record r1 -> StartRadio
mkStartRadio r = StartRadio $ Prelude.merge r defaultStartRadio

mergeStartRadio :: StartRadio -> StartRadio -> StartRadio
mergeStartRadio (StartRadio l) (StartRadio r) = StartRadio
  { __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


-- | Message generated by __protobuf__ from `StopRadio`
newtype StopRadio = StopRadio StopRadioR
type StopRadioRow =
  ( __unknown_fields :: Array Prelude.UnknownField
  )
type StopRadioR = Record StopRadioRow
derive instance genericStopRadio :: Prelude.Generic StopRadio _
derive instance newtypeStopRadio :: Prelude.Newtype StopRadio _
derive instance eqStopRadio :: Prelude.Eq StopRadio
instance showStopRadio :: Prelude.Show StopRadio where show x = Prelude.genericShow x

putStopRadio :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => StopRadio -> Prelude.PutM m Prelude.Unit
putStopRadio (StopRadio r) = do

  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseStopRadio :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m StopRadio
parseStopRadio length = Prelude.label "StopRadio / " $
  Prelude.parseMessage StopRadio defaultStopRadio parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder StopRadioR StopRadioR)

  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultStopRadio :: StopRadioR
defaultStopRadio =
  { __unknown_fields: []
  }

mkStopRadio :: forall r1 r3. Prelude.Union r1 StopRadioRow r3 => Prelude.Nub r3 StopRadioRow => Record r1 -> StopRadio
mkStopRadio r = StopRadio $ Prelude.merge r defaultStopRadio

mergeStopRadio :: StopRadio -> StopRadio -> StopRadio
mergeStopRadio (StopRadio l) (StopRadio r) = StopRadio
  { __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


-- | Message generated by __protobuf__ from `ConnectTCP`
newtype ConnectTCP = ConnectTCP ConnectTCPR
type ConnectTCPRow =
  ( host :: Prelude.Maybe String
  , port :: Prelude.Maybe String
  , __unknown_fields :: Array Prelude.UnknownField
  )
type ConnectTCPR = Record ConnectTCPRow
derive instance genericConnectTCP :: Prelude.Generic ConnectTCP _
derive instance newtypeConnectTCP :: Prelude.Newtype ConnectTCP _
derive instance eqConnectTCP :: Prelude.Eq ConnectTCP
instance showConnectTCP :: Prelude.Show ConnectTCP where show x = Prelude.genericShow x

putConnectTCP :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => ConnectTCP -> Prelude.PutM m Prelude.Unit
putConnectTCP (ConnectTCP r) = do
  Prelude.putOptional 1 r.host Prelude.isDefault Prelude.encodeStringField
  Prelude.putOptional 2 r.port Prelude.isDefault Prelude.encodeStringField
  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseConnectTCP :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m ConnectTCP
parseConnectTCP length = Prelude.label "ConnectTCP / " $
  Prelude.parseMessage ConnectTCP defaultConnectTCP parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder ConnectTCPR ConnectTCPR)
  parseField 1 Prelude.LenDel = Prelude.label "host / " $ do
    x <- Prelude.decodeString
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "host") $ \_ -> Prelude.Just x
  parseField 2 Prelude.LenDel = Prelude.label "port / " $ do
    x <- Prelude.decodeString
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "port") $ \_ -> Prelude.Just x
  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultConnectTCP :: ConnectTCPR
defaultConnectTCP =
  { host: Prelude.Nothing
  , port: Prelude.Nothing
  , __unknown_fields: []
  }

mkConnectTCP :: forall r1 r3. Prelude.Union r1 ConnectTCPRow r3 => Prelude.Nub r3 ConnectTCPRow => Record r1 -> ConnectTCP
mkConnectTCP r = ConnectTCP $ Prelude.merge r defaultConnectTCP

mergeConnectTCP :: ConnectTCP -> ConnectTCP -> ConnectTCP
mergeConnectTCP (ConnectTCP l) (ConnectTCP r) = ConnectTCP
  { host: Prelude.alt l.host r.host
  , port: Prelude.alt l.port r.port
  , __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


-- | Message generated by __protobuf__ from `Envelope`
newtype Envelope = Envelope EnvelopeR
type EnvelopeRow =
  ( payload :: Prelude.Maybe Envelope_Payload
  , __unknown_fields :: Array Prelude.UnknownField
  )
type EnvelopeR = Record EnvelopeRow
derive instance genericEnvelope :: Prelude.Generic Envelope _
derive instance newtypeEnvelope :: Prelude.Newtype Envelope _
derive instance eqEnvelope :: Prelude.Eq Envelope
instance showEnvelope :: Prelude.Show Envelope where show x = Prelude.genericShow x

putEnvelope :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Envelope -> Prelude.PutM m Prelude.Unit
putEnvelope (Envelope r) = do
  case r.payload of
    Prelude.Nothing -> pure Prelude.unit
    Prelude.Just (Envelope_Payload_M1 x) -> Prelude.putOptional 1 (Prelude.Just x) (\_ -> false) $ Prelude.putLenDel putStartRadio
    Prelude.Just (Envelope_Payload_M2 x) -> Prelude.putOptional 2 (Prelude.Just x) (\_ -> false) $ Prelude.putLenDel putStopRadio
    Prelude.Just (Envelope_Payload_M3 x) -> Prelude.putOptional 3 (Prelude.Just x) (\_ -> false) $ Prelude.putLenDel putConnectTCP
  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseEnvelope :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m Envelope
parseEnvelope length = Prelude.label "Envelope / " $
  Prelude.parseMessage Envelope defaultEnvelope parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder EnvelopeR EnvelopeR)
  parseField 1 Prelude.LenDel = Prelude.label "m1 / " $ do
    x <- Prelude.parseLenDel parseStartRadio
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "payload") $ mergeEnvelope_Payload (Prelude.Just (Envelope_Payload_M1 x))
  parseField 2 Prelude.LenDel = Prelude.label "m2 / " $ do
    x <- Prelude.parseLenDel parseStopRadio
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "payload") $ mergeEnvelope_Payload (Prelude.Just (Envelope_Payload_M2 x))
  parseField 3 Prelude.LenDel = Prelude.label "m3 / " $ do
    x <- Prelude.parseLenDel parseConnectTCP
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "payload") $ mergeEnvelope_Payload (Prelude.Just (Envelope_Payload_M3 x))
  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultEnvelope :: EnvelopeR
defaultEnvelope =
  { payload: Prelude.Nothing
  , __unknown_fields: []
  }

mkEnvelope :: forall r1 r3. Prelude.Union r1 EnvelopeRow r3 => Prelude.Nub r3 EnvelopeRow => Record r1 -> Envelope
mkEnvelope r = Envelope $ Prelude.merge r defaultEnvelope
data Envelope_Payload
  = Envelope_Payload_M1 StartRadio
  | Envelope_Payload_M2 StopRadio
  | Envelope_Payload_M3 ConnectTCP

derive instance genericEnvelope_Payload :: Prelude.Generic Envelope_Payload _
derive instance eqEnvelope_Payload :: Prelude.Eq Envelope_Payload
instance showEnvelope_Payload :: Prelude.Show Envelope_Payload where show = Prelude.genericShow

mergeEnvelope_Payload :: Prelude.Maybe Envelope_Payload -> Prelude.Maybe Envelope_Payload -> Prelude.Maybe Envelope_Payload
mergeEnvelope_Payload l r = case Prelude.Tuple l r of
  Prelude.Tuple (Prelude.Just (Envelope_Payload_M1 l')) (Prelude.Just (Envelope_Payload_M1 r')) -> Prelude.map Envelope_Payload_M1 $ Prelude.mergeWith mergeStartRadio (Prelude.Just l') (Prelude.Just r')
  Prelude.Tuple (Prelude.Just (Envelope_Payload_M2 l')) (Prelude.Just (Envelope_Payload_M2 r')) -> Prelude.map Envelope_Payload_M2 $ Prelude.mergeWith mergeStopRadio (Prelude.Just l') (Prelude.Just r')
  Prelude.Tuple (Prelude.Just (Envelope_Payload_M3 l')) (Prelude.Just (Envelope_Payload_M3 r')) -> Prelude.map Envelope_Payload_M3 $ Prelude.mergeWith mergeConnectTCP (Prelude.Just l') (Prelude.Just r')
  _ -> Prelude.alt l r

mergeEnvelope :: Envelope -> Envelope -> Envelope
mergeEnvelope (Envelope l) (Envelope r) = Envelope
  { payload: mergeEnvelope_Payload l.payload r.payload
  , __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


